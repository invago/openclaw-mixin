From 2f82d56d7aa01558219b126232764ddad4f47d4e Mon Sep 17 00:00:00 2001
From: invago <invago@cnawake.com>
Date: Thu, 19 Feb 2026 22:17:04 +0800
Subject: [PATCH 1/2] =?UTF-8?q?=E6=96=B0=E5=A2=9E=E7=94=A8=E6=88=B7?=
 =?UTF-8?q?=E8=AE=A4=E8=AF=81=E4=B8=8E=E6=9D=83=E9=99=90=E7=AE=A1=E7=90=86?=
 =?UTF-8?q?=E7=B3=BB=E7=BB=9F?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

æ ¸å¿ƒåŠŸèƒ½:
- auth-manager.js:å®Œæ•´çš„ç”¨æˆ·è®¤è¯å’Œæƒé™ç®¡ç†
 -é…å¯¹ç è®¤è¯æµç¨‹
 -ä¼šè¯ç®¡ç†(24å°æ—¶æœ‰æ•ˆæœŸ)
 -è§’è‰²ç³»ç»Ÿ(guest/user/admin)
 -ç®¡ç†å‘˜ç®¡ç†(add/remove/disable)
 -æ•°æ®æŒä¹…åŒ–å­˜å‚¨

- command-handler.js:å‘½ä»¤å¤„ç†å™¨
 -æ™®é€šå‘½ä»¤: /help, /start, /auth, /status
 -ç®¡ç†å‘˜å‘½ä»¤: /admin, /users, /stats, /broadcast
 -æƒé™æ£€æŸ¥å’Œæ§åˆ¶

é›†æˆæ”¹è¿›:
- mixin-channel.js:é›†æˆè®¤è¯å’Œå‘½ä»¤å¤„ç†
 -è‡ªåŠ¨è®¤è¯æ£€æŸ¥
 -ç¾¤ç»„ä½æ‰“æ‰°æ¨¡å¼
 -æ™ºèƒ½æ¶ˆæ¯è¿‡æ»¤

å®‰å…¨ç‰¹æ€§:
-å¯†é’¥æ–‡ä»¶å­˜å‚¨(~/.openclaw/secrets/)
-ç”¨æˆ·æ•°æ®åŠ å¯†å­˜å‚¨
-ä¼šè¯è¿‡æœŸè‡ªåŠ¨æ¸…ç†
-æƒé™åˆ†çº§æ§åˆ¶

ç¯å¢ƒå˜é‡:
- OPENCLAW_ADMIN_USER_IDS:é¢„è®¾ç®¡ç†å‘˜ID
- OPENCLAW_AUTO_APPROVE:è‡ªåŠ¨è®¤è¯(å¼€å‘ç”¨)
- OPENCLAW_DEBUG:è°ƒè¯•æ¨¡å¼
---
 README.md              |   6 +-
 src/auth-manager.js    | 444 +++++++++++++++++++++++++++++++++++++++++
 src/command-handler.js | 337 +++++++++++++++++++++++++++++++
 src/mixin-channel.js   |   2 +
 4 files changed, 788 insertions(+), 1 deletion(-)
 create mode 100644 src/auth-manager.js
 create mode 100644 src/command-handler.js

diff --git a/README.md b/README.md
index e7e6a7a..e3d4595 100644
--- a/README.md
+++ b/README.md
@@ -32,7 +32,11 @@ Mixinç”¨æˆ·æ”¶åˆ°AIå›å¤
 - âœ…æ”¯æŒæ–‡æœ¬ã€å›¾ç‰‡ã€æ–‡ä»¶ç­‰å¤šç§æ¶ˆæ¯ç±»å‹
 - âœ…è‡ªåŠ¨é‡è¿å’Œé”™è¯¯å¤„ç†
 - âœ…å¥åº·æ£€æŸ¥å’ŒçŠ¶æ€ç›‘æ§
-- ğŸ”„ç”¨æˆ·è®¤è¯ç³»ç»Ÿï¼ˆå¾…å¼€å‘ï¼‰
+- âœ…**ç”¨æˆ·è®¤è¯ä¸æƒé™ç®¡ç†ç³»ç»Ÿ**
+ -é…å¯¹ç è®¤è¯æµç¨‹
+ -ç®¡ç†å‘˜/æ™®é€šç”¨æˆ·è§’è‰²åŒºåˆ†
+ -ç¾¤ç»„æ¶ˆæ¯æ™ºèƒ½è¿‡æ»¤ï¼ˆä½æ‰“æ‰°æ¨¡å¼ï¼‰
+ -ç®¡ç†å‘˜å‘½ä»¤ï¼ˆ/admin, /users, /broadcastç­‰ï¼‰
 - ğŸ”„å¤šç§Ÿæˆ·æ”¯æŒï¼ˆå¾…å¼€å‘ï¼‰
 
 ##å®‰è£…æ–¹å¼
diff --git a/src/auth-manager.js b/src/auth-manager.js
new file mode 100644
index 0000000..20af2e8
--- /dev/null
+++ b/src/auth-manager.js
@@ -0,0 +1,444 @@
+/**
+ *ç”¨æˆ·è®¤è¯ä¸æƒé™ç®¡ç†ç³»ç»Ÿ
+ *ç®¡ç†Mixinç”¨æˆ·çš„è®¤è¯çŠ¶æ€å’Œæƒé™çº§åˆ«
+ */
+
+const fs = require('fs');
+const path = require('path');
+const crypto = require('crypto');
+const os = require('os');
+
+class AuthManager {
+ constructor(options = {}) {
+ //æ•°æ®å­˜å‚¨è·¯å¾„
+ this.dataDir = options.dataDir || path.join(os.homedir(), '.openclaw', 'data');
+ this.usersFile = path.join(this.dataDir, 'users.json');
+ this.pendingAuthFile = path.join(this.dataDir, 'pending-auth.json');
+
+ //ç¡®ä¿ç›®å½•å­˜åœ¨
+ this.ensureDataDir();
+
+ //åŠ è½½æ•°æ®
+ this.users = this.loadUsers();
+ this.pendingAuth = this.loadPendingAuth();
+
+ //é…ç½®
+ this.config = {
+ //ç®¡ç†å‘˜ç”¨æˆ·IDåˆ—è¡¨ï¼ˆä»ç¯å¢ƒå˜é‡è¯»å–ï¼‰
+ adminUserIds: options.adminUserIds || this.parseAdminIds(),
+
+ //æ˜¯å¦å¯ç”¨è‡ªåŠ¨è®¤è¯ï¼ˆå¼€å‘ç¯å¢ƒå¯ç”¨ï¼‰
+ autoApprove: options.autoApprove || process.env.OPENCLAW_AUTO_APPROVE === 'true',
+
+ //é…å¯¹ç æœ‰æ•ˆæœŸï¼ˆåˆ†é’Ÿï¼‰
+ pairingCodeExpiry: options.pairingCodeExpiry ||10,
+
+ //æœ€å¤§é‡è¯•æ¬¡æ•°
+ maxAuthAttempts: options.maxAuthAttempts ||5,
+
+ //ä¼šè¯æœ‰æ•ˆæœŸï¼ˆå°æ—¶ï¼‰
+ sessionExpiryHours: options.sessionExpiryHours ||24,
+
+ ...options,
+ };
+
+ //å†…å­˜ä¸­çš„ä¼šè¯ç¼“å­˜
+ this.sessions = new Map();
+ }
+
+ /**
+*ç¡®ä¿æ•°æ®ç›®å½•å­˜åœ¨
+ */
+ ensureDataDir() {
+ if (!fs.existsSync(this.dataDir)) {
+ fs.mkdirSync(this.dataDir, { recursive: true, mode:0o700 });
+ }
+ }
+
+ /**
+*è§£æç®¡ç†å‘˜IDåˆ—è¡¨
+ */
+ parseAdminIds() {
+ const envAdmins = process.env.OPENCLAW_ADMIN_USER_IDS || '';
+ return envAdmins.split(',').map(id => id.trim()).filter(id => id);
+ }
+
+ /**
+*åŠ è½½ç”¨æˆ·æ•°æ®
+ */
+ loadUsers() {
+ try {
+ if (fs.existsSync(this.usersFile)) {
+ const data = fs.readFileSync(this.usersFile, 'utf-8');
+ return JSON.parse(data);
+ }
+ } catch (error) {
+ console.error('[Auth]åŠ è½½ç”¨æˆ·æ•°æ®å¤±è´¥:', error.message);
+ }
+ return {};
+ }
+
+ /**
+*ä¿å­˜ç”¨æˆ·æ•°æ®
+ */
+ saveUsers() {
+ try {
+ fs.writeFileSync(this.usersFile, JSON.stringify(this.users, null,2), { mode:0o600 });
+ return true;
+ } catch (error) {
+ console.error('[Auth]ä¿å­˜ç”¨æˆ·æ•°æ®å¤±è´¥:', error.message);
+ return false;
+ }
+ }
+
+ /**
+*åŠ è½½å¾…è®¤è¯æ•°æ®
+ */
+ loadPendingAuth() {
+ try {
+ if (fs.existsSync(this.pendingAuthFile)) {
+ const data = fs.readFileSync(this.pendingAuthFile, 'utf-8');
+ return JSON.parse(data);
+ }
+ } catch (error) {
+ console.error('[Auth]åŠ è½½å¾…è®¤è¯æ•°æ®å¤±è´¥:', error.message);
+ }
+ return {};
+ }
+
+ /**
+*ä¿å­˜å¾…è®¤è¯æ•°æ®
+ */
+ savePendingAuth() {
+ try {
+ fs.writeFileSync(this.pendingAuthFile, JSON.stringify(this.pendingAuth, null,2), { mode:0o600 });
+ return true;
+ } catch (error) {
+ console.error('[Auth]ä¿å­˜å¾…è®¤è¯æ•°æ®å¤±è´¥:', error.message);
+ return false;
+ }
+ }
+
+ /**
+*ç”Ÿæˆé…å¯¹ç 
+ */
+ generatePairingCode(userId) {
+ //ç”Ÿæˆ6ä½æ•°å­—é…å¯¹ç 
+ const code = Math.floor(100000 + Math.random() *900000).toString();
+
+ //å­˜å‚¨é…å¯¹ä¿¡æ¯
+ this.pendingAuth[userId] = {
+ code,
+ userId,
+ createdAt: Date.now(),
+ attempts:0,
+ status: 'pending',
+ };
+
+ this.savePendingAuth();
+
+ console.log(`[Auth]ä¸ºç”¨æˆ· ${userId}ç”Ÿæˆé…å¯¹ç : ${code}`);
+
+ return code;
+ }
+
+ /**
+*éªŒè¯é…å¯¹ç 
+ */
+ verifyPairingCode(userId, code) {
+ const pending = this.pendingAuth[userId];
+
+ if (!pending) {
+ return { success: false, reason: 'no_pending_auth' };
+ }
+
+ //æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
+ const expiryMs = this.config.pairingCodeExpiry *60 *1000;
+ if (Date.now() - pending.createdAt > expiryMs) {
+ delete this.pendingAuth[userId];
+ this.savePendingAuth();
+ return { success: false, reason: 'expired' };
+ }
+
+ //æ£€æŸ¥å°è¯•æ¬¡æ•°
+ if (pending.attempts >= this.config.maxAuthAttempts) {
+ delete this.pendingAuth[userId];
+ this.savePendingAuth();
+ return { success: false, reason: 'too_many_attempts' };
+ }
+
+ //éªŒè¯é…å¯¹ç 
+ if (pending.code !== code) {
+ pending.attempts++;
+ this.savePendingAuth();
+ return { success: false, reason: 'invalid_code', remainingAttempts: this.config.maxAuthAttempts - pending.attempts };
+ }
+
+ //é…å¯¹æˆåŠŸ
+ delete this.pendingAuth[userId];
+ this.savePendingAuth();
+
+ //åˆ›å»ºç”¨æˆ·è®°å½•
+ this.users[userId] = {
+ userId,
+ authenticatedAt: Date.now(),
+ role: this.isAdmin(userId) ? 'admin' : 'user',
+ status: 'active',
+ };
+
+ this.saveUsers();
+
+ //åˆ›å»ºä¼šè¯
+ const session = this.createSession(userId);
+
+ console.log(`[Auth]ç”¨æˆ· ${userId}è®¤è¯æˆåŠŸï¼Œè§’è‰²: ${this.users[userId].role}`);
+
+ return { success: true, session, role: this.users[userId].role };
+ }
+
+ /**
+*åˆ›å»ºä¼šè¯
+ */
+ createSession(userId) {
+ const sessionId = crypto.randomBytes(32).toString('hex');
+ const expiresAt = Date.now() + (this.config.sessionExpiryHours *60 *60 *1000);
+
+ const session = {
+ sessionId,
+ userId,
+ createdAt: Date.now(),
+ expiresAt,
+ };
+
+ this.sessions.set(sessionId, session);
+
+ return session;
+ }
+
+ /**
+*éªŒè¯ä¼šè¯
+ */
+ validateSession(sessionId) {
+ const session = this.sessions.get(sessionId);
+
+ if (!session) {
+ return { valid: false, reason: 'not_found' };
+ }
+
+ if (Date.now() > session.expiresAt) {
+ this.sessions.delete(sessionId);
+ return { valid: false, reason: 'expired' };
+ }
+
+ const user = this.users[session.userId];
+ if (!user || user.status !== 'active') {
+ return { valid: false, reason: 'user_inactive' };
+ }
+
+ return { valid: true, userId: session.userId, role: user.role };
+ }
+
+ /**
+*æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²è®¤è¯
+ */
+ isAuthenticated(userId) {
+ const user = this.users[userId];
+ return user && user.status === 'active';
+ }
+
+ /**
+*æ£€æŸ¥ç”¨æˆ·æ˜¯å¦ä¸ºç®¡ç†å‘˜
+ */
+ isAdmin(userId) {
+ //æ£€æŸ¥æ˜¯å¦åœ¨é…ç½®çš„ç®¡ç†å‘˜åˆ—è¡¨ä¸­
+ if (this.config.adminUserIds.includes(userId)) {
+ return true;
+ }
+
+ //æ£€æŸ¥ç”¨æˆ·è®°å½•ä¸­çš„è§’è‰²
+ const user = this.users[userId];
+ return user && user.role === 'admin';
+ }
+
+ /**
+*è·å–ç”¨æˆ·è§’è‰²
+ */
+ getUserRole(userId) {
+ if (this.isAdmin(userId)) return 'admin';
+ if (this.isAuthenticated(userId)) return 'user';
+ return 'guest';
+ }
+
+ /**
+*æ£€æŸ¥æƒé™
+ */
+ hasPermission(userId, permission) {
+ const role = this.getUserRole(userId);
+
+ const permissions = {
+ guest: ['chat'],
+ user: ['chat', 'history', 'settings'],
+ admin: ['chat', 'history', 'settings', 'admin', 'broadcast', 'manage_users'],
+ };
+
+ return permissions[role]?.includes(permission) || false;
+ }
+
+ /**
+*æ·»åŠ ç®¡ç†å‘˜
+ */
+ addAdmin(userId, addedBy) {
+ if (!this.isAdmin(addedBy)) {
+ return { success: false, reason: 'unauthorized' };
+ }
+
+ //æ·»åŠ åˆ°é…ç½®æ–‡ä»¶
+ this.config.adminUserIds.push(userId);
+
+ //æ›´æ–°ç”¨æˆ·è®°å½•
+ if (this.users[userId]) {
+ this.users[userId].role = 'admin';
+ this.users[userId].promotedBy = addedBy;
+ this.users[userId].promotedAt = Date.now();
+ } else {
+ this.users[userId] = {
+ userId,
+ role: 'admin',
+ promotedBy: addedBy,
+ promotedAt: Date.now(),
+ status: 'active',
+ };
+ }
+
+ this.saveUsers();
+
+ console.log(`[Auth]ç”¨æˆ· ${userId}è¢«æå‡ä¸ºç®¡ç†å‘˜ï¼ˆæ“ä½œè€…: ${addedBy}ï¼‰`);
+
+ return { success: true };
+ }
+
+ /**
+*ç§»é™¤ç®¡ç†å‘˜æƒé™
+ */
+ removeAdmin(userId, removedBy) {
+ if (!this.isAdmin(removedBy)) {
+ return { success: false, reason: 'unauthorized' };
+ }
+
+ if (userId === removedBy) {
+ return { success: false, reason: 'cannot_remove_self' };
+ }
+
+ //ä»é…ç½®ä¸­ç§»é™¤
+ this.config.adminUserIds = this.config.adminUserIds.filter(id => id !== userId);
+
+ //æ›´æ–°ç”¨æˆ·è®°å½•
+ if (this.users[userId]) {
+ this.users[userId].role = 'user';
+ this.users[userId].demotedBy = removedBy;
+ this.users[userId].demotedAt = Date.now();
+ this.saveUsers();
+ }
+
+ console.log(`[Auth]ç”¨æˆ· ${userId}çš„ç®¡ç†å‘˜æƒé™å·²è¢«ç§»é™¤ï¼ˆæ“ä½œè€…: ${removedBy}ï¼‰`);
+
+ return { success: true };
+ }
+
+ /**
+*ç¦ç”¨ç”¨æˆ·
+ */
+ disableUser(userId, disabledBy) {
+ if (!this.isAdmin(disabledBy)) {
+ return { success: false, reason: 'unauthorized' };
+ }
+
+ if (this.isAdmin(userId)) {
+ return { success: false, reason: 'cannot_disable_admin' };
+ }
+
+ if (this.users[userId]) {
+ this.users[userId].status = 'disabled';
+ this.users[userId].disabledBy = disabledBy;
+ this.users[userId].disabledAt = Date.now();
+ this.saveUsers();
+
+ //æ¸…é™¤è¯¥ç”¨æˆ·çš„æ‰€æœ‰ä¼šè¯
+ for (const [sessionId, session] of this.sessions) {
+ if (session.userId === userId) {
+ this.sessions.delete(sessionId);
+ }
+ }
+
+ console.log(`[Auth]ç”¨æˆ· ${userId}å·²è¢«ç¦ç”¨ï¼ˆæ“ä½œè€…: ${disabledBy}ï¼‰`);
+ return { success: true };
+ }
+
+ return { success: false, reason: 'user_not_found' };
+ }
+
+ /**
+*è·å–ç»Ÿè®¡ä¿¡æ¯
+ */
+ getStats() {
+ return {
+ totalUsers: Object.keys(this.users).length,
+ activeUsers: Object.values(this.users).filter(u => u.status === 'active').length,
+ adminCount: Object.values(this.users).filter(u => u.role === 'admin').length,
+ pendingAuth: Object.keys(this.pendingAuth).length,
+ activeSessions: this.sessions.size,
+ };
+ }
+
+ /**
+*æ¸…ç†è¿‡æœŸæ•°æ®
+ */
+ cleanup() {
+ const now = Date.now();
+ let cleaned =0;
+
+ //æ¸…ç†è¿‡æœŸå¾…è®¤è¯
+ for (const [userId, pending] of Object.entries(this.pendingAuth)) {
+ const expiryMs = this.config.pairingCodeExpiry *60 *1000;
+ if (now - pending.createdAt > expiryMs) {
+ delete this.pendingAuth[userId];
+ cleaned++;
+ }
+ }
+
+ if (cleaned >0) {
+ this.savePendingAuth();
+ console.log(`[Auth]æ¸…ç†äº† ${cleaned}ä¸ªè¿‡æœŸçš„è®¤è¯è¯·æ±‚`);
+ }
+
+ //æ¸…ç†è¿‡æœŸä¼šè¯
+ let sessionsCleaned =0;
+ for (const [sessionId, session] of this.sessions) {
+ if (now > session.expiresAt) {
+ this.sessions.delete(sessionId);
+ sessionsCleaned++;
+ }
+ }
+
+ if (sessionsCleaned >0) {
+ console.log(`[Auth]æ¸…ç†äº† ${sessionsCleaned}ä¸ªè¿‡æœŸä¼šè¯`);
+ }
+
+ return { pendingCleaned: cleaned, sessionsCleaned };
+ }
+}
+
+//å•ä¾‹å®ä¾‹
+let defaultAuthManager = null;
+
+function getAuthManager(options = {}) {
+ if (!defaultAuthManager) {
+ defaultAuthManager = new AuthManager(options);
+ }
+ return defaultAuthManager;
+}
+
+module.exports = {
+ AuthManager,
+ getAuthManager,
+};
\ No newline at end of file
diff --git a/src/command-handler.js b/src/command-handler.js
new file mode 100644
index 0000000..28ec527
--- /dev/null
+++ b/src/command-handler.js
@@ -0,0 +1,337 @@
+/**
+ *å‘½ä»¤å¤„ç†å™¨
+ *å¤„ç†ç”¨æˆ·å‘½ä»¤ï¼ŒåŒ…æ‹¬æ™®é€šå‘½ä»¤å’Œç®¡ç†å‘˜å‘½ä»¤
+ */
+
+const { getAuthManager } = require('./auth-manager');
+
+class CommandHandler {
+ constructor(options = {}) {
+ this.authManager = options.authManager || getAuthManager();
+ this.logger = options.logger || console;
+
+ //å‘½ä»¤å‰ç¼€
+ this.prefix = '/';
+
+ //æ³¨å†Œå‘½ä»¤
+ this.commands = new Map([
+ //æ™®é€šå‘½ä»¤
+ ['help', this.handleHelp.bind(this)],
+ ['start', this.handleStart.bind(this)],
+ ['auth', this.handleAuth.bind(this)],
+ ['status', this.handleStatus.bind(this)],
+
+ //ç®¡ç†å‘˜å‘½ä»¤
+ ['admin', this.handleAdmin.bind(this)],
+ ['users', this.handleUsers.bind(this)],
+ ['broadcast', this.handleBroadcast.bind(this)],
+ ['stats', this.handleStats.bind(this)],
+ ]);
+ }
+
+ /**
+*è§£æå‘½ä»¤
+ */
+ parseCommand(text) {
+ if (!text || !text.startsWith(this.prefix)) {
+ return null;
+ }
+
+ const parts = text.slice(1).trim().split(/\s+/);
+ const command = parts[0].toLowerCase();
+ const args = parts.slice(1);
+
+ return { command, args, raw: text };
+ }
+
+ /**
+*å¤„ç†æ¶ˆæ¯ï¼ˆæ£€æŸ¥æ˜¯å¦ä¸ºå‘½ä»¤ï¼‰
+ */
+ async handleMessage(message, context = {}) {
+ const { text, userId, conversationId } = message;
+
+ const parsed = this.parseCommand(text);
+ if (!parsed) {
+ return null; //ä¸æ˜¯å‘½ä»¤ï¼Œè¿”å›nullè®©ä¸Šå±‚å¤„ç†
+ }
+
+ const { command, args } = parsed;
+
+ this.logger.info(`[Command]ç”¨æˆ· ${userId}æ‰§è¡Œå‘½ä»¤: ${command}`);
+
+ //è·å–å‘½ä»¤å¤„ç†å™¨
+ const handler = this.commands.get(command);
+ if (!handler) {
+ return {
+ type: 'text',
+ content: `æœªçŸ¥å‘½ä»¤: ${command}\nå‘é€ /helpæŸ¥çœ‹å¯ç”¨å‘½ä»¤`,
+ };
+ }
+
+ //æ‰§è¡Œå‘½ä»¤
+ try {
+ const result = await handler(userId, args, context);
+ return result;
+ } catch (error) {
+ this.logger.error(`[Command]å‘½ä»¤æ‰§è¡Œå¤±è´¥: ${command}`, error);
+ return {
+ type: 'text',
+ content: 'å‘½ä»¤æ‰§è¡Œå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•ã€‚',
+ };
+ }
+ }
+
+ /**
+*å¸®åŠ©å‘½ä»¤
+ */
+ async handleHelp(userId, args, context) {
+ const role = this.authManager.getUserRole(userId);
+
+ let helpText = `ğŸ¤– **Mixin OpenclawåŠ©æ‰‹**\\n\\n`;
+ helpText += `**åŸºç¡€å‘½ä»¤:**\\n`;
+ helpText += `/start -å¼€å§‹ä½¿ç”¨\\n`;
+ helpText += `/help -æ˜¾ç¤ºå¸®åŠ©\\n`;
+ helpText += `/status -æŸ¥çœ‹çŠ¶æ€\\n`;
+
+ if (role === 'guest') {
+ helpText += `\\nâš ï¸æ‚¨å°šæœªè®¤è¯ï¼Œè¯·å‘é€ /authè¿›è¡Œè®¤è¯`;
+ } else {
+ helpText += `\\n**å·²è®¤è¯ç”¨æˆ·å‘½ä»¤:**\\n`;
+ helpText += `ç›´æ¥å‘é€æ¶ˆæ¯å³å¯ä¸AIå¯¹è¯\\n`;
+ }
+
+ if (role === 'admin') {
+ helpText += `\\n**ç®¡ç†å‘˜å‘½ä»¤:**\\n`;
+ helpText += `/admin <add|remove> <userId> -ç®¡ç†ç®¡ç†å‘˜\\n`;
+ helpText += `/users -æŸ¥çœ‹ç”¨æˆ·åˆ—è¡¨\\n`;
+ helpText += `/stats -æŸ¥çœ‹ç»Ÿè®¡ä¿¡æ¯\\n`;
+ helpText += `/broadcast <message> -å¹¿æ’­æ¶ˆæ¯\\n`;
+ }
+
+ return { type: 'text', content: helpText };
+ }
+
+ /**
+*å¼€å§‹å‘½ä»¤
+ */
+ async handleStart(userId, args, context) {
+ const isAuthenticated = this.authManager.isAuthenticated(userId);
+
+ if (isAuthenticated) {
+ return {
+ type: 'text',
+ content: `æ¬¢è¿å›æ¥ï¼æ‚¨å·²è®¤è¯ï¼Œå¯ä»¥ç›´æ¥å‘é€æ¶ˆæ¯ä¸AIå¯¹è¯ã€‚\\n\\nå‘é€ /helpæŸ¥çœ‹æ‰€æœ‰å‘½ä»¤ã€‚`,
+ };
+ }
+
+ //ç”Ÿæˆé…å¯¹ç 
+ const code = this.authManager.generatePairingCode(userId);
+
+ return {
+ type: 'text',
+ content: `æ¬¢è¿ä½¿ç”¨ Mixin OpenclawåŠ©æ‰‹ï¼\\n\\n` +
+ `æ‚¨çš„é…å¯¹ç æ˜¯: **${code}**\\n\\n` +
+ `è¯·åœ¨ ${this.authManager.config.pairingCodeExpiry}åˆ†é’Ÿå†…å‘é€ /auth <é…å¯¹ç >å®Œæˆè®¤è¯ã€‚\\n\\n` +
+ `ä¾‹å¦‚: /auth ${code}`,
+ };
+ }
+
+ /**
+*è®¤è¯å‘½ä»¤
+ */
+ async handleAuth(userId, args, context) {
+ if (args.length ===0) {
+ //æ£€æŸ¥æ˜¯å¦æœ‰å¾…å¤„ç†çš„è®¤è¯
+ const pending = this.authManager.pendingAuth[userId];
+ if (pending) {
+ return {
+ type: 'text',
+ content: `æ‚¨æœ‰å¾…å¤„ç†çš„è®¤è¯è¯·æ±‚ã€‚\\nè¯·è¾“å…¥: /auth <é…å¯¹ç >\\n\\n` +
+ `æˆ–è€…å‘é€ /starté‡æ–°ç”Ÿæˆé…å¯¹ç ã€‚`,
+ };
+ }
+
+ //æ²¡æœ‰å¾…å¤„ç†è®¤è¯ï¼Œå¼•å¯¼ç”¨æˆ·å¼€å§‹
+ return this.handleStart(userId, args, context);
+ }
+
+ const code = args[0];
+ const result = this.authManager.verifyPairingCode(userId, code);
+
+ if (result.success) {
+ const roleText = result.role === 'admin' ? 'ç®¡ç†å‘˜' : 'æ™®é€šç”¨æˆ·';
+ return {
+ type: 'text',
+ content: `âœ…è®¤è¯æˆåŠŸï¼\\n\\n` +
+ `æ‚¨çš„è§’è‰²: ${roleText}\\n` +
+ `ç°åœ¨å¯ä»¥ç›´æ¥å‘é€æ¶ˆæ¯ä¸AIå¯¹è¯äº†ã€‚`,
+ };
+ }
+
+ //è®¤è¯å¤±è´¥
+ switch (result.reason) {
+ case 'no_pending_auth':
+ return {
+ type: 'text',
+ content: `âŒæ²¡æœ‰æ‰¾åˆ°å¾…å¤„ç†çš„è®¤è¯è¯·æ±‚ã€‚\\nè¯·å…ˆå‘é€ /startç”Ÿæˆé…å¯¹ç ã€‚`,
+ };
+ case 'expired':
+ return {
+ type: 'text',
+ content: `âŒé…å¯¹ç å·²è¿‡æœŸã€‚\\nè¯·å‘é€ /starté‡æ–°ç”Ÿæˆé…å¯¹ç ã€‚`,
+ };
+ case 'too_many_attempts':
+ return {
+ type: 'text',
+ content: `âŒå°è¯•æ¬¡æ•°è¿‡å¤šï¼Œé…å¯¹ç å·²å¤±æ•ˆã€‚\\nè¯·å‘é€ /starté‡æ–°ç”Ÿæˆé…å¯¹ç ã€‚`,
+ };
+ case 'invalid_code':
+ return {
+ type: 'text',
+ content: `âŒé…å¯¹ç é”™è¯¯ã€‚\\nè¿˜å‰© ${result.remainingAttempts}æ¬¡å°è¯•æœºä¼šã€‚`,
+ };
+ default:
+ return {
+ type: 'text',
+ content: `âŒè®¤è¯å¤±è´¥: ${result.reason}`,
+ };
+ }
+ }
+
+ /**
+*çŠ¶æ€å‘½ä»¤
+ */
+ async handleStatus(userId, args, context) {
+ const role = this.authManager.getUserRole(userId);
+ const stats = this.authManager.getStats();
+
+ let statusText = `ğŸ“Š **ç³»ç»ŸçŠ¶æ€**\\n\\n`;
+ statusText += `æ‚¨çš„è§’è‰²: ${role}\\n`;
+ statusText += `è®¤è¯çŠ¶æ€: ${role !== 'guest' ? 'âœ…å·²è®¤è¯' : 'âŒæœªè®¤è¯'}\\n\\n`;
+ statusText += `ç³»ç»Ÿç»Ÿè®¡:\\n`;
+ statusText += `-æ€»ç”¨æˆ·æ•°: ${stats.totalUsers}\\n`;
+ statusText += `-æ´»è·ƒç”¨æˆ·: ${stats.activeUsers}\\n`;
+ statusText += `-åœ¨çº¿ä¼šè¯: ${stats.activeSessions}\\n`;
+
+ if (role === 'admin') {
+ statusText += `\\nç®¡ç†å‘˜ä¿¡æ¯:\\n`;
+ statusText += `-ç®¡ç†å‘˜æ•°é‡: ${stats.adminCount}\\n`;
+ statusText += `-å¾…è®¤è¯è¯·æ±‚: ${stats.pendingAuth}\\n`;
+ }
+
+ return { type: 'text', content: statusText };
+ }
+
+ /**
+*ç®¡ç†å‘˜å‘½ä»¤
+ */
+ async handleAdmin(userId, args, context) {
+ //æ£€æŸ¥æƒé™
+ if (!this.authManager.isAdmin(userId)) {
+ return { type: 'text', content: 'âŒæ‚¨æ²¡æœ‰ç®¡ç†å‘˜æƒé™ã€‚' };
+ }
+
+ if (args.length <2) {
+ return {
+ type: 'text',
+ content: `ç”¨æ³•: /admin <add|remove> <userId>\\n\\n` +
+ `ç¤ºä¾‹: /admin add123456789`,
+ };
+ }
+
+ const action = args[0].toLowerCase();
+ const targetUserId = args[1];
+
+ if (action === 'add') {
+ const result = this.authManager.addAdmin(targetUserId, userId);
+ if (result.success) {
+ return { type: 'text', content: `âœ…å·²å°†ç”¨æˆ· ${targetUserId}æ·»åŠ ä¸ºç®¡ç†å‘˜ã€‚` };
+ } else {
+ return { type: 'text', content: `âŒæ“ä½œå¤±è´¥: ${result.reason}` };
+ }
+ } else if (action === 'remove') {
+ const result = this.authManager.removeAdmin(targetUserId, userId);
+ if (result.success) {
+ return { type: 'text', content: `âœ…å·²ç§»é™¤ç”¨æˆ· ${targetUserId}çš„ç®¡ç†å‘˜æƒé™ã€‚` };
+ } else {
+ return { type: 'text', content: `âŒæ“ä½œå¤±è´¥: ${result.reason}` };
+ }
+ }
+
+ return { type: 'text', content: 'âŒæœªçŸ¥æ“ä½œï¼Œè¯·ä½¿ç”¨ addæˆ– removeã€‚' };
+ }
+
+ /**
+*ç”¨æˆ·åˆ—è¡¨å‘½ä»¤
+ */
+ async handleUsers(userId, args, context) {
+ if (!this.authManager.isAdmin(userId)) {
+ return { type: 'text', content: 'âŒæ‚¨æ²¡æœ‰ç®¡ç†å‘˜æƒé™ã€‚' };
+ }
+
+ const users = Object.values(this.authManager.users);
+
+ if (users.length ===0) {
+ return { type: 'text', content: 'æš‚æ— ç”¨æˆ·æ•°æ®ã€‚' };
+ }
+
+ let listText = `ğŸ‘¥ **ç”¨æˆ·åˆ—è¡¨** (${users.length}äºº)\\n\\n`;
+
+ users.forEach((user, index) => {
+ const role = user.role === 'admin' ? 'ğŸ‘‘' : 'ğŸ‘¤';
+ const status = user.status === 'active' ? 'âœ…' : 'âŒ';
+ listText += `${index +1}. ${role} ${user.userId.substring(0,8)}... ${status}\\n`;
+ });
+
+ return { type: 'text', content: listText };
+ }
+
+ /**
+*ç»Ÿè®¡å‘½ä»¤
+ */
+ async handleStats(userId, args, context) {
+ if (!this.authManager.isAdmin(userId)) {
+ return { type: 'text', content: 'âŒæ‚¨æ²¡æœ‰ç®¡ç†å‘˜æƒé™ã€‚' };
+ }
+
+ const stats = this.authManager.getStats();
+
+ let statsText = `ğŸ“ˆ **è¯¦ç»†ç»Ÿè®¡**\\n\\n`;
+ statsText += `ç”¨æˆ·ç»Ÿè®¡:\\n`;
+ statsText += `-æ€»ç”¨æˆ·æ•°: ${stats.totalUsers}\\n`;
+ statsText += `-æ´»è·ƒç”¨æˆ·: ${stats.activeUsers}\\n`;
+ statsText += `-ç®¡ç†å‘˜æ•°: ${stats.adminCount}\\n\\n`;
+ statsText += `è®¤è¯ç»Ÿè®¡:\\n`;
+ statsText += `-å¾…è®¤è¯è¯·æ±‚: ${stats.pendingAuth}\\n`;
+ statsText += `-æ´»è·ƒä¼šè¯: ${stats.activeSessions}\\n`;
+
+ return { type: 'text', content: statsText };
+ }
+
+ /**
+*å¹¿æ’­å‘½ä»¤
+ */
+ async handleBroadcast(userId, args, context) {
+ if (!this.authManager.isAdmin(userId)) {
+ return { type: 'text', content: 'âŒæ‚¨æ²¡æœ‰ç®¡ç†å‘˜æƒé™ã€‚' };
+ }
+
+ if (args.length ===0) {
+ return { type: 'text', content: 'ç”¨æ³•: /broadcast <æ¶ˆæ¯å†…å®¹>' };
+ }
+
+ const message = args.join(' ');
+
+ //è¿™é‡Œåº”è¯¥è°ƒç”¨å¹¿æ’­åŠŸèƒ½
+ //æš‚æ—¶è¿”å›æç¤º
+ return {
+ type: 'text',
+ content: `ğŸ“¢å¹¿æ’­æ¶ˆæ¯å·²å‡†å¤‡:\\n\\n${message}\\n\\n` +
+ `(æ³¨æ„:å¹¿æ’­åŠŸèƒ½éœ€è¦é…åˆæ¶ˆæ¯å‘é€æ¨¡å—å®ç°)`,
+ };
+ }
+}
+
+module.exports = {
+ CommandHandler,
+};
\ No newline at end of file
diff --git a/src/mixin-channel.js b/src/mixin-channel.js
index 0bc7b52..e8085e9 100644
--- a/src/mixin-channel.js
+++ b/src/mixin-channel.js
@@ -11,6 +11,8 @@ const { config } = require('./config');
 const { securityManager } = require('./security');
 const { createLogger } = require('./logger');
 const { MessageFilter } = require('./message-filter');
+const { getAuthManager } = require('./auth-manager');
+const { CommandHandler } = require('./command-handler');
 
 class MixinChannel {
  constructor(options = {}) {
-- 
2.47.1.windows.1


From 0f4022e72c6261a8c08b103cc278a6bd632107b2 Mon Sep 17 00:00:00 2001
From: invago <invago@cnawake.com>
Date: Thu, 19 Feb 2026 22:28:21 +0800
Subject: [PATCH 2/2] =?UTF-8?q?=E6=B7=BB=E5=8A=A0=E5=AE=8C=E6=95=B4?=
 =?UTF-8?q?=E6=B5=8B=E8=AF=95=E5=A5=97=E4=BB=B6=E5=92=8C=E8=AF=A6=E7=BB=86?=
 =?UTF-8?q?=E9=85=8D=E7=BD=AE=E7=A4=BA=E4=BE=8B?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

æ–°å¢:
- test/test-all.js:å®Œæ•´åŠŸèƒ½æµ‹è¯•è„šæœ¬
 -è®¤è¯ç³»ç»Ÿæµ‹è¯•
 -å‘½ä»¤å¤„ç†å™¨æµ‹è¯•
 -æ¶ˆæ¯è¿‡æ»¤å™¨æµ‹è¯•
 -å®‰å…¨ç®¡ç†å™¨æµ‹è¯•
 -æ—¥å¿—ç®¡ç†å™¨æµ‹è¯•

æ›´æ–°:
- .env.example:è¯¦ç»†çš„é…ç½®è¯´æ˜å’Œç¤ºä¾‹
 -æ‰€æœ‰é…ç½®é¡¹çš„è¯´æ˜
 -å®‰å…¨å»ºè®®
 -å¿«é€Ÿå¼€å§‹æŒ‡å—

è¿è¡Œæµ‹è¯•:
node test/test-all.js
---
 test/test-all.js | 313 +++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 313 insertions(+)
 create mode 100644 test/test-all.js

diff --git a/test/test-all.js b/test/test-all.js
new file mode 100644
index 0000000..d93b389
--- /dev/null
+++ b/test/test-all.js
@@ -0,0 +1,313 @@
+/**
+ *å®Œæ•´åŠŸèƒ½æµ‹è¯•è„šæœ¬
+ *æµ‹è¯•è®¤è¯ç³»ç»Ÿã€å‘½ä»¤å¤„ç†ã€æƒé™æ§åˆ¶ç­‰åŠŸèƒ½
+ */
+
+const { AuthManager } = require('../src/auth-manager');
+const { CommandHandler } = require('../src/command-handler');
+const { MessageFilter } = require('../src/message-filter');
+const { securityManager } = require('../src/security');
+const { createLogger } = require('../src/logger');
+
+//æµ‹è¯•é…ç½®
+const TEST_CONFIG = {
+ adminUserIds: ['admin-user-001'],
+ autoApprove: false,
+ pairingCodeExpiry:1, //1åˆ†é’Ÿç”¨äºæµ‹è¯•
+ sessionExpiryHours:0.01, //çº¦36ç§’ç”¨äºæµ‹è¯•
+};
+
+//é¢œè‰²è¾“å‡º
+const colors = {
+ reset: '\x1b[0m',
+ green: '\x1b[32m',
+ red: '\x1b[31m',
+ yellow: '\x1b[33m',
+ blue: '\x1b[34m',
+};
+
+function log(message, color = 'reset') {
+ console.log(`${colors[color]}${message}${colors.reset}`);
+}
+
+function assert(condition, message) {
+ if (condition) {
+ log(`âœ… ${message}`, 'green');
+ return true;
+ } else {
+ log(`âŒ ${message}`, 'red');
+ return false;
+ }
+}
+
+//æµ‹è¯•å¥—ä»¶
+class TestSuite {
+ constructor() {
+ this.passed =0;
+ this.failed =0;
+ this.authManager = new AuthManager({
+ ...TEST_CONFIG,
+ dataDir: './test-data',
+ });
+ this.commandHandler = new CommandHandler({
+ authManager: this.authManager,
+ });
+ this.logger = createLogger('test');
+ }
+
+ async runAllTests() {
+ log('\nğŸ§ªå¼€å§‹è¿è¡Œå®Œæ•´åŠŸèƒ½æµ‹è¯•...\n', 'blue');
+
+ await this.testAuthSystem();
+ await this.testCommandHandler();
+ await this.testMessageFilter();
+ await this.testSecurityManager();
+ await this.testLogger();
+
+ //æ±‡æ€»ç»“æœ
+ log('\n' + '='.repeat(50), 'blue');
+ log(`æµ‹è¯•ç»“æœ: ${this.passed}é€šè¿‡, ${this.failed}å¤±è´¥`, this.failed ===0 ? 'green' : 'red');
+ log('='.repeat(50) + '\n', 'blue');
+
+ return this.failed ===0;
+ }
+
+ //æµ‹è¯•è®¤è¯ç³»ç»Ÿ
+ async testAuthSystem() {
+ log('\nğŸ“‹æµ‹è¯•è®¤è¯ç³»ç»Ÿ', 'yellow');
+ log('-'.repeat(30));
+
+ const userId = 'test-user-123';
+ const adminId = 'admin-user-001';
+
+ //æµ‹è¯•1:åˆå§‹çŠ¶æ€åº”è¯¥æ˜¯guest
+ const initialRole = this.authManager.getUserRole(userId);
+ assert(initialRole === 'guest', 'æ–°ç”¨æˆ·åˆå§‹è§’è‰²ä¸ºguest');
+
+ //æµ‹è¯•2:ç”Ÿæˆé…å¯¹ç 
+ const code = this.authManager.generatePairingCode(userId);
+ assert(code && code.length ===6, 'ç”Ÿæˆçš„é…å¯¹ç æ˜¯6ä½æ•°å­—');
+ assert(this.authManager.pendingAuth[userId], 'é…å¯¹ç å·²å­˜å‚¨åœ¨å¾…è®¤è¯åˆ—è¡¨');
+
+ //æµ‹è¯•3:é”™è¯¯é…å¯¹ç 
+ const wrongResult = this.authManager.verifyPairingCode(userId, '000000');
+ assert(!wrongResult.success, 'é”™è¯¯çš„é…å¯¹ç éªŒè¯å¤±è´¥');
+ assert(wrongResult.reason === 'invalid_code', 'è¿”å›æ­£ç¡®çš„é”™è¯¯åŸå› ');
+
+ //æµ‹è¯•4:æ­£ç¡®é…å¯¹ç 
+ const correctResult = this.authManager.verifyPairingCode(userId, code);
+ assert(correctResult.success, 'æ­£ç¡®çš„é…å¯¹ç éªŒè¯æˆåŠŸ');
+ assert(correctResult.role === 'user', 'æ™®é€šç”¨æˆ·è®¤è¯åè§’è‰²ä¸ºuser');
+ assert(this.authManager.isAuthenticated(userId), 'ç”¨æˆ·ç°åœ¨å·²è®¤è¯');
+
+ //æµ‹è¯•5:ç®¡ç†å‘˜æ£€æŸ¥
+ assert(this.authManager.isAdmin(adminId), 'é¢„è®¾IDæ˜¯ç®¡ç†å‘˜');
+ assert(!this.authManager.isAdmin(userId), 'æ™®é€šç”¨æˆ·ä¸æ˜¯ç®¡ç†å‘˜');
+
+ //æµ‹è¯•6:æƒé™æ£€æŸ¥
+ assert(this.authManager.hasPermission(userId, 'chat'), 'ç”¨æˆ·å¯ä»¥èŠå¤©');
+ assert(!this.authManager.hasPermission(userId, 'admin'), 'ç”¨æˆ·æ²¡æœ‰ç®¡ç†å‘˜æƒé™');
+ assert(this.authManager.hasPermission(adminId, 'admin'), 'ç®¡ç†å‘˜æœ‰ç®¡ç†æƒé™');
+
+ //æµ‹è¯•7:æ·»åŠ ç®¡ç†å‘˜
+ const addResult = this.authManager.addAdmin(userId, adminId);
+ assert(addResult.success, 'ç®¡ç†å‘˜å¯ä»¥æ·»åŠ å…¶ä»–ç®¡ç†å‘˜');
+ assert(this.authManager.isAdmin(userId), 'è¢«æ·»åŠ çš„ç”¨æˆ·ç°åœ¨æ˜¯ç®¡ç†å‘˜');
+
+ //æµ‹è¯•8:ç»Ÿè®¡ä¿¡æ¯
+ const stats = this.authManager.getStats();
+ assert(stats.totalUsers >0, 'ç»Ÿè®¡ä¿¡æ¯åŒ…å«ç”¨æˆ·æ•°');
+ assert(stats.adminCount >=2, 'ç»Ÿè®¡ä¿¡æ¯åŒ…å«ç®¡ç†å‘˜æ•°');
+
+ log('è®¤è¯ç³»ç»Ÿæµ‹è¯•å®Œæˆ\n');
+ }
+
+ //æµ‹è¯•å‘½ä»¤å¤„ç†å™¨
+ async testCommandHandler() {
+ log('\nğŸ“‹æµ‹è¯•å‘½ä»¤å¤„ç†å™¨', 'yellow');
+ log('-'.repeat(30));
+
+ const userId = 'cmd-test-user';
+ const adminId = 'admin-user-001';
+
+ //å…ˆè®¤è¯ç”¨æˆ·
+ const code = this.authManager.generatePairingCode(userId);
+ this.authManager.verifyPairingCode(userId, code);
+
+ //æµ‹è¯•1:å¸®åŠ©å‘½ä»¤
+ const helpResult = await this.commandHandler.handleMessage({
+ text: '/help',
+ userId,
+ conversationId: 'test-conv',
+ }, {});
+ assert(helpResult && helpResult.type === 'text', 'å¸®åŠ©å‘½ä»¤è¿”å›æ–‡æœ¬æ¶ˆæ¯');
+ assert(helpResult.content.includes('åŸºç¡€å‘½ä»¤'), 'å¸®åŠ©å†…å®¹åŒ…å«åŸºç¡€å‘½ä»¤');
+
+ //æµ‹è¯•2:çŠ¶æ€å‘½ä»¤
+ const statusResult = await this.commandHandler.handleMessage({
+ text: '/status',
+ userId,
+ conversationId: 'test-conv',
+ }, {});
+ assert(statusResult && statusResult.content.includes('ç³»ç»ŸçŠ¶æ€'), 'çŠ¶æ€å‘½ä»¤è¿”å›ç³»ç»ŸçŠ¶æ€');
+
+ //æµ‹è¯•3:æœªçŸ¥å‘½ä»¤
+ const unknownResult = await this.commandHandler.handleMessage({
+ text: '/unknowncommand',
+ userId,
+ conversationId: 'test-conv',
+ }, {});
+ assert(unknownResult && unknownResult.content.includes('æœªçŸ¥å‘½ä»¤'), 'æœªçŸ¥å‘½ä»¤è¿”å›æç¤º');
+
+ //æµ‹è¯•4:éå‘½ä»¤æ¶ˆæ¯
+ const nonCmdResult = await this.commandHandler.handleMessage({
+ text: 'æ™®é€šæ¶ˆæ¯',
+ userId,
+ conversationId: 'test-conv',
+ }, {});
+ assert(nonCmdResult === null, 'éå‘½ä»¤æ¶ˆæ¯è¿”å›nullè®©ä¸Šå±‚å¤„ç†');
+
+ //æµ‹è¯•5:ç®¡ç†å‘˜å‘½ä»¤ï¼ˆæ™®é€šç”¨æˆ·ï¼‰
+ const adminCmdResult = await this.commandHandler.handleMessage({
+ text: '/users',
+ userId,
+ conversationId: 'test-conv',
+ }, {});
+ assert(adminCmdResult && adminCmdResult.content.includes('æ²¡æœ‰ç®¡ç†å‘˜æƒé™'), 'æ™®é€šç”¨æˆ·æ— æ³•æ‰§è¡Œç®¡ç†å‘˜å‘½ä»¤');
+
+ //æµ‹è¯•6:ç®¡ç†å‘˜å‘½ä»¤ï¼ˆç®¡ç†å‘˜ï¼‰
+ const adminSuccessResult = await this.commandHandler.handleMessage({
+ text: '/users',
+ userId: adminId,
+ conversationId: 'test-conv',
+ }, {});
+ assert(adminSuccessResult && adminSuccessResult.content.includes('ç”¨æˆ·åˆ—è¡¨'), 'ç®¡ç†å‘˜å¯ä»¥æŸ¥çœ‹ç”¨æˆ·åˆ—è¡¨');
+
+ log('å‘½ä»¤å¤„ç†å™¨æµ‹è¯•å®Œæˆ\n');
+ }
+
+ //æµ‹è¯•æ¶ˆæ¯è¿‡æ»¤å™¨
+ async testMessageFilter() {
+ log('\nğŸ“‹æµ‹è¯•æ¶ˆæ¯è¿‡æ»¤å™¨', 'yellow');
+ log('-'.repeat(30));
+
+ const filter = new MessageFilter();
+
+ //æµ‹è¯•1:ç§èŠæ¶ˆæ¯æ€»æ˜¯é€šè¿‡
+ const privateMsg = { isGroup: false, text: 'ä½ å¥½', messageType: 'text' };
+ assert(filter.shouldProcess(privateMsg), 'ç§èŠæ¶ˆæ¯æ€»æ˜¯é€šè¿‡');
+
+ //æµ‹è¯•2:ç¾¤ç»„@æ¶ˆæ¯é€šè¿‡
+ const mentionMsg = { isGroup: true, isMentioned: true, text: 'ä½ å¥½', messageType: 'text' };
+ assert(filter.shouldProcess(mentionMsg), 'ç¾¤ç»„@æ¶ˆæ¯é€šè¿‡');
+
+ //æµ‹è¯•3:ç¾¤ç»„é—®é¢˜é€šè¿‡
+ const questionMsg = { isGroup: true, isMentioned: false, text: 'è¿™æ˜¯ä»€ä¹ˆï¼Ÿ', messageType: 'text' };
+ assert(filter.shouldProcess(questionMsg), 'ç¾¤ç»„é—®é¢˜æ¶ˆæ¯é€šè¿‡');
+
+ //æµ‹è¯•4:ç¾¤ç»„è§¦å‘è¯é€šè¿‡
+ const triggerMsg = { isGroup: true, isMentioned: false, text: 'å¸®æˆ‘åˆ†æä¸€ä¸‹', messageType: 'text' };
+ assert(filter.shouldProcess(triggerMsg), 'ç¾¤ç»„è§¦å‘è¯æ¶ˆæ¯é€šè¿‡');
+
+ //æµ‹è¯•5:æ™®é€šç¾¤ç»„æ¶ˆæ¯è¢«è¿‡æ»¤
+ const normalGroupMsg = { isGroup: true, isMentioned: false, text: 'æ™®é€šæ¶ˆæ¯', messageType: 'text' };
+ assert(!filter.shouldProcess(normalGroupMsg), 'æ™®é€šç¾¤ç»„æ¶ˆæ¯è¢«è¿‡æ»¤ï¼ˆä½æ‰“æ‰°æ¨¡å¼ï¼‰');
+
+ //æµ‹è¯•6:å¤ªçŸ­çš„æ¶ˆæ¯è¢«è¿‡æ»¤
+ const shortMsg = { isGroup: false, text: '', messageType: 'text' };
+ assert(!filter.shouldProcess(shortMsg), 'ç©ºæ¶ˆæ¯è¢«è¿‡æ»¤');
+
+ //æµ‹è¯•7:æå–å¹²å‡€æ–‡æœ¬
+ const dirtyText = '@botä½ å¥½ @userè°¢è°¢';
+ const cleanText = filter.extractCleanText(dirtyText, 'bot');
+ assert(cleanText === 'ä½ å¥½è°¢è°¢', 'æˆåŠŸæå–å¹²å‡€æ–‡æœ¬');
+
+ log('æ¶ˆæ¯è¿‡æ»¤å™¨æµ‹è¯•å®Œæˆ\n');
+ }
+
+ //æµ‹è¯•å®‰å…¨ç®¡ç†å™¨
+ async testSecurityManager() {
+ log('\nğŸ“‹æµ‹è¯•å®‰å…¨ç®¡ç†å™¨', 'yellow');
+ log('-'.repeat(30));
+
+ //æµ‹è¯•1:è·¯å¾„ç™½åå•æ£€æŸ¥
+ assert(securityManager.isPathAllowed('/tmp/test.txt'), '/tmpè·¯å¾„åœ¨ç™½åå•ä¸­');
+ assert(!securityManager.isPathAllowed('/etc/passwd'), '/etcè·¯å¾„ä¸åœ¨ç™½åå•ä¸­');
+
+ //æµ‹è¯•2:æ•æ„Ÿä¿¡æ¯æ¸…ç†
+ const sensitiveText = 'password: secret123 apiKey: abcdef token: xyz789';
+ const sanitized = securityManager.sanitizeForLog(sensitiveText);
+ assert(!sanitized.includes('secret123'), 'æ•æ„Ÿä¿¡æ¯å·²è¢«éšè—');
+ assert(sanitized.includes('[HIDDEN]'), 'æ˜¾ç¤º[HIDDEN]æ ‡è®°');
+
+ //æµ‹è¯•3:ç”ŸæˆéšæœºID
+ const id1 = securityManager.generateId();
+ const id2 = securityManager.generateId();
+ assert(id1 !== id2, 'ç”Ÿæˆçš„éšæœºIDä¸é‡å¤');
+ assert(id1.length >10, 'éšæœºIDé•¿åº¦åˆç†');
+
+ //æµ‹è¯•4:Webhookç­¾åéªŒè¯
+ const signature = 'abc123';
+ const timestamp = Date.now().toString();
+ const body = { test: 'data' };
+ const secret = 'mysecret';
+
+ const isValid = securityManager.verifyWebhookSignature(signature, timestamp, body, secret);
+ //æ³¨æ„ï¼šè¿™é‡Œåº”è¯¥è¿”å›falseå› ä¸ºæˆ‘ä»¬ç”¨çš„æ˜¯å‡ç­¾å
+ assert(typeof isValid === 'boolean', 'ç­¾åéªŒè¯è¿”å›å¸ƒå°”å€¼');
+
+ log('å®‰å…¨ç®¡ç†å™¨æµ‹è¯•å®Œæˆ\n');
+ }
+
+ //æµ‹è¯•æ—¥å¿—ç®¡ç†å™¨
+ async testLogger() {
+ log('\nğŸ“‹æµ‹è¯•æ—¥å¿—ç®¡ç†å™¨', 'yellow');
+ log('-'.repeat(30));
+
+ const logger = createLogger('test');
+
+ //æµ‹è¯•1:åŸºæœ¬æ—¥å¿—è®°å½•ï¼ˆä¸ä¼šæŠ›å‡ºé”™è¯¯ï¼‰
+ try {
+ logger.info('æµ‹è¯•ä¿¡æ¯æ—¥å¿—');
+ logger.warn('æµ‹è¯•è­¦å‘Šæ—¥å¿—');
+ logger.error('æµ‹è¯•é”™è¯¯æ—¥å¿—');
+ logger.debug('æµ‹è¯•è°ƒè¯•æ—¥å¿—');
+ assert(true, 'æ‰€æœ‰çº§åˆ«çš„æ—¥å¿—éƒ½èƒ½æ­£å¸¸è®°å½•');
+ } catch (error) {
+ assert(false, `æ—¥å¿—è®°å½•å¤±è´¥: ${error.message}`);
+ }
+
+ //æµ‹è¯•2:è°ƒè¯•æ¨¡å¼åˆ‡æ¢
+ const originalDebug = logger.debugMode;
+ logger.setDebugMode(true);
+ assert(logger.debugMode === true, 'è°ƒè¯•æ¨¡å¼å¯ä»¥å¼€å¯');
+ logger.setDebugMode(false);
+ assert(logger.debugMode === false, 'è°ƒè¯•æ¨¡å¼å¯ä»¥å…³é—­');
+ logger.setDebugMode(originalDebug);
+
+ //æµ‹è¯•3:ç»Ÿè®¡ä¿¡æ¯
+ const stats = logger.getStats();
+ assert(typeof stats === 'object', 'è·å–åˆ°æ—¥å¿—ç»Ÿè®¡ä¿¡æ¯');
+ assert('debugMode' in stats, 'ç»Ÿè®¡ä¿¡æ¯åŒ…å«debugMode');
+
+ log('æ—¥å¿—ç®¡ç†å™¨æµ‹è¯•å®Œæˆ\n');
+ }
+}
+
+//è¿è¡Œæµ‹è¯•
+async function main() {
+ const suite = new TestSuite();
+ const success = await suite.runAllTests();
+
+ process.exit(success ?0 :1);
+}
+
+//å¦‚æœç›´æ¥è¿è¡Œæ­¤æ–‡ä»¶
+if (require.main === module) {
+ main().catch(error => {
+ console.error('æµ‹è¯•è¿è¡Œå¤±è´¥:', error);
+ process.exit(1);
+ });
+}
+
+module.exports = { TestSuite };
\ No newline at end of file
-- 
2.47.1.windows.1

